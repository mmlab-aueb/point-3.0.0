/*
 * Copyright (C) 2010-2016  George Parisis and Dirk Trossen
 * Copyright (C) 2015-2018  Mays AL-Naday
 * All rights reserved.
 *
 * The NAP and MONA deployment is supported by Sebastian Robitzsch
 * The ODL deployment is supported by George Petropoulos
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 3 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * See LICENSE and COPYING for more details.
 */

#include "network.hpp"
#include "graph_representation.hpp"
#include "parser.hpp"
#include "deployment_server.hpp"
#include <tclap/CmdLine.h>
#include "boost/filesystem/path.hpp"
#include "boost/filesystem/operations.hpp"
#include <sys/time.h>

using namespace std;
namespace fs = boost::filesystem;
struct timeval start_time;
struct timeval end_time;
struct timeval nap_time;

int main(int argc, char **argv) {
    int ret;
    string extension = "";
    string filename;
    string tgzfile;
    bool autogenerate = false;
    bool ns3 = false;
    bool transfer_binaries = false;
    bool monitor_tool_stub = false;
    bool dump_supp = false;
    bool no_lnxcap = false;
    bool no_discover = false;
    bool no_copy = false;
    bool no_start = false;
    bool no_kill = false;
	bool log = false;
    bool zones = false;
    bool nap = false;
	bool no_tm = false;
    bool lsm = false;
    bool odl = false;
    bool no_cpr = false;

    /** dynamic deployment variable
     */
    bool dynamic = false;
    gettimeofday(&start_time, NULL);
    /**parse command line block based on TCLAP (template lib)
     */
    try {
        TCLAP::CmdLine cmd("Blackadder Universal Deployment Tool ", ' ', "0.4");
        TCLAP::ValueArg<std::string> configfileArg("c", "configfile", "Configuration file or directory containing multiple configuration files, each of which contains graph attributes OR describes a graph (when -a is not used)", true, "homer", "string");
        TCLAP::ValueArg<std::string> tgzfileArg("t", "tgzfile", "tar gzipped file that gets transferred and extracted at USER home folders on all experiment targets", false, "None", "string");
        TCLAP::ValueArg<std::string> extensionArg("x", "tmextension", "Deploy the TM with a Traffic Engineering Extension", false, "", "string");
        TCLAP::SwitchArg MonToolStubSwitch("m", "montoolstub", "Enable monitor tool stub in the Click configuration files. This injects counters in click configs that are inspected at runtime via port 55000. It will be ommited for kernel versions", cmd, false);
        TCLAP::SwitchArg dumpSupp("", "rvinfo", "Enable RV info dump support (on port 55500 in the RV node if it is running on userlevel).", cmd, false);
        TCLAP::SwitchArg autoSwitch("a", "auto", "Enable graph autogeneration - a autogenerated.cfg and edgevertices.cfg files are emitted at WRITE_CONF folder. The former contains the graph to repeat the experiment and the latter the leaf nodes", cmd, false);
        TCLAP::SwitchArg ns3Switch("s", "simulate", "if this flag is on a C++ ns3 simulation description will be created", cmd, false);
        TCLAP::SwitchArg nolnxCap("", "nolnxcap", "Use PCAP as the default packet capturing method instead of LINUX in FromDevice element", cmd, false);
		TCLAP::SwitchArg logCap("l", "log", "log click printouts in /tmp/ba_log_NODEID text file", cmd, false);
        TCLAP::SwitchArg noDiscover("", "nodiscover", "Don't auto-discover MAC addresses.", cmd, false);
        TCLAP::SwitchArg noCopy("", "nocopy", "Don't copy files to nodes.", cmd, false);
        TCLAP::SwitchArg noStart("", "nostart", "Don't start/stop Click.", cmd, false);
        TCLAP::SwitchArg noKill("", "nokill", "Don't start/stop Click.", cmd, false);
		TCLAP::SwitchArg noTM("", "notm", "Don't start/stop TM.", cmd, false);
        TCLAP::SwitchArg Zoned("z", "zones", "Use the configuration files provided in a configuration directory to create a single network domain comprised of multiple zones", cmd, false);
        TCLAP::SwitchArg NAP("n", "nap", "run the NAP application in each click node", cmd, false);
        TCLAP::SwitchArg lsmSwitch("r", "linkstatemonitor", "Deploy the LSM application for traffic engineering support", cmd, false);
        TCLAP::SwitchArg configureOdl("o", "odl", "Configure the ABM rules via the ODL controller", cmd, false);
        TCLAP::SwitchArg noCPR("", "nocpr", "Disable Control Plane Reliability module", cmd, false);

        /** check the dynamic deployment variable
         */
        TCLAP::SwitchArg dynamicDeployment("", "dynamic", "Start dynamic deployment tool.", cmd, false);

        cmd.add(configfileArg);
        cmd.add(tgzfileArg);
        cmd.add(extensionArg);
        cmd.parse(argc, argv);

        /**get config filename. This is mandatory argument so we can skip existence check
         */
        filename = configfileArg.getValue();
        tgzfile = tgzfileArg.getValue();
        extension = extensionArg.getValue();
        
        /** check if autogenerate flag was set
         */
        autogenerate = autoSwitch.getValue();
        /** check if ns3 simulation code must be created
         */
        ns3 = ns3Switch.getValue();
        /**if experiment file argument is not the default value the experiment deploy flag should be true
         */
        if (tgzfile != string("None")) {
            transfer_binaries = true;
        }
        /**Get monitor tool stub flag
         */
        monitor_tool_stub = MonToolStubSwitch.getValue();
        if ((ns3 && autogenerate) || (ns3 && monitor_tool_stub)) {
            cout << "You can't have it all!! ns3 switch must not be combined with the auto switch or the monitor tool switch" << endl;
            exit(1);
        }
        /** check if LINUX method is to be used instead of PCAP in click FromDevice()
         */
        no_lnxcap=nolnxCap.getValue();
        dump_supp = dumpSupp.getValue();
        no_discover = noDiscover.getValue();
        no_copy = noCopy.getValue();
        no_start = noStart.getValue();
        no_kill = noKill.getValue();
		log = logCap.getValue();
        zones = Zoned.getValue();
        nap = NAP.getValue();
		no_tm = noTM.getValue();
        lsm = lsmSwitch.getValue();
        odl = configureOdl.getValue();
        no_cpr = noCPR.getValue();
        cout << "TM extension: " << extension << endl;

        /** set the value of dynamic boolean variable
         */
        dynamic = dynamicDeployment.getValue();
    } catch (TCLAP::ArgException &e)
        /**catch any command parsing exceptions
         */ {
             cout << "PARSE ERROS IS HERE..." << endl;
        std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl;
    }
    /*Set the TM extensions*/
    
    if (zones) {
        string parserinputfile = "";
        dm = Domain();
        list<Domain *> dm_zones;
        fs::path full_path( fs::initial_path<fs::path>() );
        full_path = fs::system_complete( fs::path( filename ) );
        
        unsigned int file_count = 0;
        unsigned int err_count = 0;
        if ( !fs::exists( full_path ) )
        {
            std::cout << "\nNot found: " << full_path.string() << std::endl;
            return 1;
        }
        if ( fs::is_directory( full_path ) )
        {
            std::cout << "\nIn directory: "
            << full_path.string() << "\n\n";
            fs::directory_iterator end_iter;
            dm = Domain();
            fs::directory_iterator dir_itr( full_path );
            parserinputfile = full_path.string() + dir_itr->path().filename().string();
            Parser parser(((char *) parserinputfile.c_str()), &dm);
            for (; dir_itr != end_iter; ++dir_itr )
            {
                try
                {
                    if ( fs::is_regular_file( dir_itr->status() ) )
                    {
                        ++file_count;
                        std::cout << dir_itr->path().filename() << "\n";
                        parserinputfile = full_path.string() + dir_itr->path().filename().string();
                        if (file_count <= 1) {
                            /*first domain, so construct a parsing object pointing to the domain*/
                            ret = parser.buildNetworkDomain();
                        }
                        else {
                            /*subsequent domains, so add to the domain pointer of the parsing object*/
                            parser.file = (char *) parserinputfile.c_str();
                            parser.expandNetworkDomain();
                        }
                    }
                }
                catch ( const std::exception & ex )
                {
                    ++err_count;
                    std::cout << dir_itr->path().filename() << " " << ex.what() << std::endl;
                }
            }
            parser.joinZones();
            std::cout << "\n" << file_count << " files\n"
            << err_count << " errors\n";
        }
        else // must be a file
        {
            std::cout << "\nFound: " << full_path.string() << "\n";
        }
    } else {
        /**if autogenerated flag is set, a autogenerated file is built and it is then loaded with the proper chain of commands
         */
        string autoconffile = "";
        if (autogenerate) {
            /**create an empty network representation.
             */
            Domain pdm = Domain();
            /**create a parser object. the configuration file and the network domain are the parameters.
             */
            Parser parserp(((char *) filename.c_str()), &pdm);
            /**Build PlanetLab Domain out of the planetlab available node file input
             */
            ret = parserp.buildPlanetLabDomain();
            /**Global domain parameteres should be explicitly called at this stage
             */
            ret = parserp.getGlobalDomainParameters();
            /**Check for errors
             */
            if (ret < 0) {
                cout << "Get global domain parameters: Something went wrong: " << ret << endl;
                return EXIT_FAILURE;
            }
            /**create a graph representation of the network domain. if autogenerated is true, the an igraph instance will be now created using the Barabasi-Albert model
             */
            GraphRepresentation graphp = GraphRepresentation(&pdm, autogenerate);
            /** the igraph barabasi instance previously created will be traversed, to build
             the deployment tool internal representation so that click configuration file generation and deployment execution
             can be carried out by the same code with the non-autogenerated graph input.
             */
            graphp.BuildInputMap();
            graphp.ChooseTheBestTMRVNode();
            /**Write albert-barabasi autogenerated standard configuration file format
             */
            autoconffile = pdm.writeConfigFile("autogenerated.cfg");
            /**Calculate leaf Vertices
             */
            graphp.OutputLeafVertices("edgevertices.cfg");
        }
        
        /**create an empty network representation.
         */
        dm = Domain();
        /**create a parser object. the configuration file and the network domain are the parameters.
         */
        string parserinputfile = "";
        if (autogenerate) {
            parserinputfile = autoconffile;
        } else {
            parserinputfile = filename;
        }
        Parser parser(((char *) parserinputfile.c_str()), &dm);
        if (!ns3) {
            /**In the typical scenario parse the configuration file and build the network domain (add nodes and connections).
             */
            ret = parser.buildNetworkDomain();
        } else {
            ret = parser.buildNS3NetworkDomain();
        }
        /** Check for errors
         */
        if (ret < 0) {
            cout << "Build network domain: Something went wrong: " << ret << endl;
            return EXIT_FAILURE;
        }
    }
    /**create a graph representation of the network domain. if autogenerated is true, the an igraph instance will be now created using the Barabasi-Albert model
     */
    GraphRepresentation graph = GraphRepresentation(&dm, autogenerate);
    /**assign Link Identifiers and internal link identifiers using a randomly generated set of LIDs.
     */
    dm.assignLIDs();
    /** assign the same LIDs to both directions of a link and the same LID to iLID of leaf nodes.
     * commented because does not work with SDN, modified solution that give unique directional LIDs to SDN links only is required
     */
    //dm.assignLIDs_rm();
    /**transform the network domain representation to iGraph representation.
     */
    graph.buildIGraphTopology();
    /**Calculate the default forwarding identifiers from each node to the domain's Rendezvous Node.
     */
    graph.calculateRVFIDs();
    /**Calculate the default forwarding identifiers from each node to the domain's Topology Manager.
     */
    graph.calculateTMFIDs();
    /**discover the MAC addresses (when needed) for each connection in the network domain.
     */
    if (!ns3) {
        dm.discoverMacAddresses(no_discover);
    } else {
        dm.assignDeviceNamesAndMacAddresses();
    }
    /**write all Click/Blackadder Configuration files.
     */
    if (!ns3) {
        dm.writeClickFiles(monitor_tool_stub, dump_supp, no_lnxcap, no_cpr);
        //if flows are to be configured by ODL controller call the appropriate function
        //else write flows directly to switches
        if (odl)
        	dm.configureOdlController();
        dm.writeOFlows(odl);
    } else {
        /**\todo: findout if FromSimDevice() in NS3 uses pcap and whether it has the same timeout issue "https://github.com/kohler/click/issues/164: as FromDevice()
         */
        dm.writeNS3ClickFiles();
    }
    /**Tranfer a .tgz file from path to all nodes and also issue a tar zxvf command.
     */
    if (transfer_binaries and !no_copy) {
        dm.scpClickBinary(tgzfile);
    }
    /**copy the Click configuration to each blackadder node.
     */
    if (!ns3) {
        /**copy the Click configuration to each Blackadder node.
         */
        if (!no_copy) {
            dm.scpClickFiles();
        }
        /** kill the Click configuration on each Blackadder node before starting
         */
        if (!no_kill) {
            dm.killClick();
            dm.killNAP();
//			dm.killMonServer();
            dm.killMA();
            /*for path management kill any running linkstatemonitor (LSM)*/
            if(lsm)
                dm.killLSM();
        }
        /**Start Click using the copied configuration file.
         */
        if (!no_start) {
            dm.startClick(log, odl);
        }
    }
    /**set some graph attributes for the topology manager
     */
    cout << "Finished click " << endl;
    igraph_cattribute_GAN_set(&graph.igraph, "FID_LEN", dm.fid_len);
    igraph_cattribute_GAS_set(&graph.igraph, "TM", dm.TM_node->label.c_str());
    igraph_cattribute_GAS_set(&graph.igraph, "RV", dm.RV_node->label.c_str());
    cout << "TM is " << dm.TM_node->label << endl;
    cout << "RV is " << dm.RV_node->label << endl;
    igraph_cattribute_GAS_set(&graph.igraph, "TM_MODE", dm.TM_node->running_mode.c_str());
    FILE * outstream_graphml = fopen(string(dm.write_conf + "topology.graphml").c_str(), "w");
    // The following happens if BA has been previously deployed from another machine
    // so the file exists with root permissions.
    if (outstream_graphml == NULL){
        cout<<"Could not open file "<<string(dm.write_conf + "topology.graphml")<<"\n";
        cout<<"Try 'sudo rm "<<string(dm.write_conf + "topology.graphml")<<"' and re-deploy...\n";
        return -13;
    }
#if IGRAPH_V >= IGRAPH_V_0_7
    // igraph 0.7 (maybe >=0.6.2 has by default?) can add a prefix we
    // probably do not want to add it (it allows for clash of vertex
    // and edge names)
    igraph_write_graph_graphml(&graph.igraph, outstream_graphml,true);
#else
    igraph_write_graph_graphml(&graph.igraph, outstream_graphml);
#endif
    fclose(outstream_graphml);
    if (!ns3) {
        /** Copy the .graphml file to the Topology Manager node.
         */
        if (!no_copy) {
            dm.scpTMConfiguration("topology.graphml");
        }
        /**Start the Topology Manager at the right node.
         */
        if(!no_start){
            if(!no_tm){
                cout << "starting TM..." << endl;
                dm.startTM(log, extension);
            }
            dm.startMA();
            if (lsm) {
                dm.startLSM(log);
            }
        }
    }
    if (!ns3) {
        if (!no_start) {
            if (nap) {
                gettimeofday(&nap_time, NULL);
                cout << "starting NAP" << endl;
                dm.startNAP(log);
            } else {
                nap_time.tv_sec=0;
            }
        }
    }
    if (ns3) {
        dm.createNS3SimulationCode();
    }
    cout << "Done." << endl;
    
    /** If dynamic variable is set to true, start the deployment server
     * to listen for incoming requests.
     */
    if (dynamic) {
        boost::asio::io_service io_service;
        server s(io_service, 9999);
        s.init();
    }
    gettimeofday(&end_time, NULL);
    cout << "Deployment: \nTotal Period: " << (end_time.tv_sec - start_time.tv_sec) << " secs " << endl << "NAP Period: " << (end_time.tv_sec - nap_time.tv_sec) << " secs" << endl;
}
